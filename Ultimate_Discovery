# Active Directory Discovery Assessment PowerShell Scripts - Complete Suite
# Optimized for large environments with progress tracking and ETAs
# Run with appropriate domain admin privileges

#Requires -Version 5.1
#Requires -Modules ActiveDirectory, DnsServer, GroupPolicy

# Global Configuration
$Global:OutputPath = "C:\AD_Assessment"
$Global:BatchSize = 100  # Process items in batches to avoid memory issues
$Global:StartTime = Get-Date
$Global:ProgressPreference = 'Continue'

# Create output directory
if (!(Test-Path $Global:OutputPath)) {
    New-Item -ItemType Directory -Path $Global:OutputPath -Force | Out-Null
}

# Helper function for ETA calculation
function Get-ETA {
    param(
        [int]$Current,
        [int]$Total,
        [datetime]$StartTime
    )
    
    if ($Current -eq 0) { return "Calculating..." }
    
    $ElapsedTime = (Get-Date) - $StartTime
    $ItemsPerSecond = $Current / $ElapsedTime.TotalSeconds
    $RemainingItems = $Total - $Current
    $EstimatedSeconds = $RemainingItems / $ItemsPerSecond
    
    if ($EstimatedSeconds -gt 3600) {
        return "{0:N1} hours" -f ($EstimatedSeconds / 3600)
    } elseif ($EstimatedSeconds -gt 60) {
        return "{0:N0} minutes" -f ($EstimatedSeconds / 60)
    } else {
        return "{0:N0} seconds" -f $EstimatedSeconds
    }
}

# Create log file
$LogFile = "$Global:OutputPath\AD_Assessment_Log_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
function Write-Log {
    param($Message)
    $LogMessage = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - $Message"
    $LogMessage | Out-File -FilePath $LogFile -Append
    Write-Host $LogMessage
}

Write-Log "Starting AD Discovery Assessment"
Write-Log "Output Path: $Global:OutputPath"

#region SCRIPT 1: AD USERS ASSESSMENT

function Get-ADUsersAssessment {
    Write-Log "=== Starting AD Users Assessment ==="
    
    $ScriptStartTime = Get-Date
    $CutoffDate = (Get-Date).AddDays(-120)
    
    # Get total user count first
    Write-Host "Counting total AD users..." -ForegroundColor Yellow
    $TotalUserCount = (Get-ADUser -Filter * -ResultSetSize $null).Count
    Write-Log "Total AD Users found: $TotalUserCount"
    
    # Initialize collections
    $AllUsers = @()
    $ProcessedCount = 0
    
    # Process users in batches
    $SearchBase = (Get-ADDomain).DistinguishedName
    $Searcher = [adsisearcher]"(&(objectCategory=person)(objectClass=user))"
    $Searcher.SearchRoot = [adsi]"LDAP://$SearchBase"
    $Searcher.PageSize = $Global:BatchSize
    $Searcher.PropertiesToLoad.AddRange(@(
        'samaccountname','displayname','userprincipalname','useraccountcontrol',
        'lastlogontimestamp','pwdlastset','whencreated','description',
        'department','title','manager','memberof','distinguishedname','mail','employeeid'
    ))
    
    Write-Host "Processing $TotalUserCount users in batches of $Global:BatchSize..." -ForegroundColor Green
    
    $Results = $Searcher.FindAll()
    
    foreach ($Result in $Results) {
        $ProcessedCount++
        
        # Update progress every 10 users
        if ($ProcessedCount % 10 -eq 0) {
            $PercentComplete = ($ProcessedCount / $TotalUserCount) * 100
            $ETA = Get-ETA -Current $ProcessedCount -Total $TotalUserCount -StartTime $ScriptStartTime
            
            Write-Progress -Activity "Processing AD Users" `
                -Status "Processing user $ProcessedCount of $TotalUserCount - ETA: $ETA" `
                -PercentComplete $PercentComplete `
                -CurrentOperation "Analyzing user accounts..."
        }
        
        try {
            $User = $Result.Properties
            
            # Convert timestamps
            $LastLogon = $null
            if ($User['lastlogontimestamp'] -and $User['lastlogontimestamp'][0] -gt 0) {
                $LastLogon = [DateTime]::FromFileTime($User['lastlogontimestamp'][0])
            }
            
            $PwdLastSet = $null
            if ($User['pwdlastset'] -and $User['pwdlastset'][0] -gt 0) {
                $PwdLastSet = [DateTime]::FromFileTime($User['pwdlastset'][0])
            }
            
            $UAC = $User['useraccountcontrol'][0]
            $Enabled = -not ($UAC -band 2)  # Check if account is enabled
            
            # Determine account type
            $SamAccountName = $User['samaccountname'][0]
            $Description = if ($User['description']) { $User['description'][0] } else { "" }
            
            $AccountType = if ($SamAccountName -match '(svc|service|app)' -or $Description -match '(service|application|system)') {
                "Service Account"
            } elseif ($SamAccountName -match '(admin|adm|_a$)') {
                "Admin Account"
            } else {
                "Standard User"
            }
            
            # Check if active
            $IsActive = $Enabled -and (($LastLogon -gt $CutoffDate) -or ($PwdLastSet -gt $CutoffDate))
            
            # Get group memberships (limit to first 50 to avoid performance issues)
            $Groups = @()
            if ($User['memberof']) {
                $GroupCount = 0
                foreach ($GroupDN in $User['memberof']) {
                    if ($GroupCount -ge 50) { 
                        $Groups += "...(truncated)"
                        break 
                    }
                    try {
                        $GroupName = $GroupDN -replace '^CN=([^,]+),.*$', '$1'
                        $Groups += $GroupName
                        $GroupCount++
                    } catch {}
                }
            }
            
            $UserObject = [PSCustomObject]@{
                SamAccountName = $SamAccountName
                DisplayName = if ($User['displayname']) { $User['displayname'][0] } else { "" }
                UserPrincipalName = if ($User['userprincipalname']) { $User['userprincipalname'][0] } else { "" }
                Email = if ($User['mail']) { $User['mail'][0] } else { "" }
                EmployeeID = if ($User['employeeid']) { $User['employeeid'][0] } else { "" }
                Enabled = $Enabled
                LastLogonDate = $LastLogon
                PasswordLastSet = $PwdLastSet
                WhenCreated = $User['whencreated'][0]
                Description = $Description
                Department = if ($User['department']) { $User['department'][0] } else { "" }
                Title = if ($User['title']) { $User['title'][0] } else { "" }
                AccountType = $AccountType
                IsActive = $IsActive
                GroupCount = $Groups.Count
                MemberOf = $Groups -join '; '
            }
            
            $AllUsers += $UserObject
            
            # Export in batches to avoid memory issues
            if ($AllUsers.Count -ge 1000) {
                $AllUsers | Export-Csv "$Global:OutputPath\All_AD_Users.csv" -NoTypeInformation -Append
                $AllUsers = @()
            }
            
        } catch {
            Write-Log "Error processing user: $($_.Exception.Message)"
        }
    }
    
    # Export remaining users
    if ($AllUsers.Count -gt 0) {
        $AllUsers | Export-Csv "$Global:OutputPath\All_AD_Users.csv" -NoTypeInformation -Append
    }
    
    Write-Progress -Activity "Processing AD Users" -Completed
    Write-Log "User processing completed. Generating summary reports..."
    
    # Generate filtered reports
    Write-Host "Generating user category reports..." -ForegroundColor Yellow
    
    # Read back the full user list for categorization
    $AllUsersData = Import-Csv "$Global:OutputPath\All_AD_Users.csv"
    
    # Active Standard Users
    $AllUsersData | Where-Object {$_.AccountType -eq "Standard User" -and $_.IsActive -eq "True"} |
        Export-Csv "$Global:OutputPath\Active_Standard_Users.csv" -NoTypeInformation
    
    # Active Admin Accounts
    $AllUsersData | Where-Object {$_.AccountType -eq "Admin Account" -and $_.IsActive -eq "True"} |
        Export-Csv "$Global:OutputPath\Active_Admin_Users.csv" -NoTypeInformation
    
    # Service Accounts
    $ServiceAccounts = $AllUsersData | Where-Object {$_.AccountType -eq "Service Account"}
    $ServiceAccounts | Export-Csv "$Global:OutputPath\Service_Accounts.csv" -NoTypeInformation
    
    # Generate summary statistics
    $UserStats = [PSCustomObject]@{
        TotalUsers = $AllUsersData.Count
        ActiveStandardUsers = ($AllUsersData | Where-Object {$_.AccountType -eq "Standard User" -and $_.IsActive -eq "True"}).Count
        ActiveAdminUsers = ($AllUsersData | Where-Object {$_.AccountType -eq "Admin Account" -and $_.IsActive -eq "True"}).Count
        ServiceAccountsTotal = $ServiceAccounts.Count
        ActiveServiceAccounts = ($ServiceAccounts | Where-Object {$_.IsActive -eq "True"}).Count
        InactiveUsers = ($AllUsersData | Where-Object {$_.IsActive -eq "False"}).Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $UserStats | Export-Csv "$Global:OutputPath\User_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "User assessment completed in $([math]::Round($UserStats.ProcessingTime, 2)) minutes"
    
    # Clean up
    $Results.Dispose()
    [GC]::Collect()
}

#endregion

#region SCRIPT 2: AD COMPUTERS ASSESSMENT

function Get-ADComputersAssessment {
    Write-Log "=== Starting AD Computers Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Get total computer count
    Write-Host "Counting total AD computers..." -ForegroundColor Yellow
    $TotalComputerCount = (Get-ADComputer -Filter * -ResultSetSize $null).Count
    Write-Log "Total AD Computers found: $TotalComputerCount"
    
    $AllComputers = @()
    $ProcessedCount = 0
    
    # Process computers in batches
    Get-ADComputer -Filter * -ResultSetSize $null -Properties * | ForEach-Object -Begin {
        $BatchComputers = @()
    } -Process {
        $ProcessedCount++
        
        # Update progress
        if ($ProcessedCount % 5 -eq 0) {
            $PercentComplete = ($ProcessedCount / $TotalComputerCount) * 100
            $ETA = Get-ETA -Current $ProcessedCount -Total $TotalComputerCount -StartTime $ScriptStartTime
            
            Write-Progress -Activity "Processing AD Computers" `
                -Status "Processing computer $ProcessedCount of $TotalComputerCount - ETA: $ETA" `
                -PercentComplete $PercentComplete `
                -CurrentOperation "Analyzing computer: $($_.Name)"
        }
        
        try {
            $Computer = $_
            $OSVersion = $Computer.OperatingSystem
            $OSVersionNumber = $Computer.OperatingSystemVersion
            
            # Determine OS type and compliance
            $OSType = if ($OSVersion -like "*Server*") { "Server" } else { "Workstation" }
            $IsCompliant = $false
            
            if ($OSVersion -like "*Windows 10*" -or $OSVersion -like "*Windows 11*" -or 
                $OSVersion -like "*Server 2016*" -or $OSVersion -like "*Server 2019*" -or 
                $OSVersion -like "*Server 2022*") {
                $IsCompliant = $true
            }
            
            # Check if computer is active (logged in within 90 days)
            $IsActive = $false
            if ($Computer.LastLogonDate) {
                $IsActive = $Computer.LastLogonDate -gt (Get-Date).AddDays(-90)
            }
            
            $ComputerObject = [PSCustomObject]@{
                Name = $Computer.Name
                DNSHostName = $Computer.DNSHostName
                Enabled = $Computer.Enabled
                OperatingSystem = $OSVersion
                OperatingSystemVersion = $OSVersionNumber
                OSType = $OSType
                IsCompliant = $IsCompliant
                IsActive = $IsActive
                LastLogonDate = $Computer.LastLogonDate
                WhenCreated = $Computer.WhenCreated
                Description = $Computer.Description
                DistinguishedName = $Computer.DistinguishedName
                IPv4Address = $Computer.IPv4Address
                Location = $Computer.Location
            }
            
            $BatchComputers += $ComputerObject
            
            # Export in batches
            if ($BatchComputers.Count -ge 500) {
                $BatchComputers | Export-Csv "$Global:OutputPath\All_AD_Computers.csv" -NoTypeInformation -Append
                $BatchComputers = @()
            }
            
        } catch {
            Write-Log "Error processing computer $($_.Name): $($_.Exception.Message)"
        }
    } -End {
        # Export remaining computers
        if ($BatchComputers.Count -gt 0) {
            $BatchComputers | Export-Csv "$Global:OutputPath\All_AD_Computers.csv" -NoTypeInformation -Append
        }
    }
    
    Write-Progress -Activity "Processing AD Computers" -Completed
    Write-Log "Computer processing completed. Generating OS summary..."
    
    # Generate OS Summary
    $ComputersData = Import-Csv "$Global:OutputPath\All_AD_Computers.csv"
    
    $OSSummary = $ComputersData | Group-Object OperatingSystem | 
        Select-Object @{N='OperatingSystem';E={$_.Name}}, Count |
        Sort-Object Count -Descending
    
    $OSSummary | Export-Csv "$Global:OutputPath\Computer_OS_Summary.csv" -NoTypeInformation
    
    # Computer Statistics
    $ComputerStats = [PSCustomObject]@{
        TotalComputers = $ComputersData.Count
        ActiveComputers = ($ComputersData | Where-Object {$_.IsActive -eq "True"}).Count
        CompliantComputers = ($ComputersData | Where-Object {$_.IsCompliant -eq "True"}).Count
        NonCompliantComputers = ($ComputersData | Where-Object {$_.IsCompliant -eq "False"}).Count
        Servers = ($ComputersData | Where-Object {$_.OSType -eq "Server"}).Count
        Workstations = ($ComputersData | Where-Object {$_.OSType -eq "Workstation"}).Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $ComputerStats | Export-Csv "$Global:OutputPath\Computer_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "Computer assessment completed in $([math]::Round($ComputerStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 3: PRINTERS ASSESSMENT

function Get-PrintersAssessment {
    Write-Log "=== Starting Printers Assessment ==="
    
    $ScriptStartTime = Get-Date
    $AllPrinters = @()
    
    try {
        # Get all published printers from AD
        Write-Host "Searching for published printers in AD..." -ForegroundColor Yellow
        
        $Searcher = [adsisearcher]"(&(objectCategory=printQueue))"
        $Searcher.PageSize = 1000
        $Searcher.PropertiesToLoad.AddRange(@(
            'printername','servername','drivername','location',
            'description','portname','printsharename','whencreated'
        ))
        
        $Results = $Searcher.FindAll()
        $TotalPrinters = $Results.Count
        Write-Log "Found $TotalPrinters published printers"
        
        $ProcessedCount = 0
        
        foreach ($Result in $Results) {
            $ProcessedCount++
            
            if ($ProcessedCount % 10 -eq 0) {
                $PercentComplete = ($ProcessedCount / $TotalPrinters) * 100
                Write-Progress -Activity "Processing Printers" `
                    -Status "Processing printer $ProcessedCount of $TotalPrinters" `
                    -PercentComplete $PercentComplete
            }
            
            $Printer = $Result.Properties
            
            $PrinterObject = [PSCustomObject]@{
                PrinterName = if ($Printer['printername']) { $Printer['printername'][0] } else { "" }
                ServerName = if ($Printer['servername']) { $Printer['servername'][0] } else { "" }
                DriverName = if ($Printer['drivername']) { $Printer['drivername'][0] } else { "" }
                Location = if ($Printer['location']) { $Printer['location'][0] } else { "" }
                Description = if ($Printer['description']) { $Printer['description'][0] } else { "" }
                PortName = if ($Printer['portname']) { $Printer['portname'][0] } else { "" }
                ShareName = if ($Printer['printsharename']) { $Printer['printsharename'][0] } else { "" }
                WhenCreated = if ($Printer['whencreated']) { $Printer['whencreated'][0] } else { "" }
            }
            
            $AllPrinters += $PrinterObject
        }
        
        $Results.Dispose()
        
    } catch {
        Write-Log "Error searching for AD printers: $($_.Exception.Message)"
    }
    
    # Also get print servers
    Write-Host "Identifying print servers..." -ForegroundColor Yellow
    
    $PrintServers = @()
    try {
        $Servers = Get-ADComputer -Filter {OperatingSystem -like "*Server*"} -Properties OperatingSystem
        
        foreach ($Server in $Servers) {
            try {
                $PrintSpooler = Get-Service -ComputerName $Server.Name -Name Spooler -ErrorAction SilentlyContinue
                if ($PrintSpooler.Status -eq 'Running') {
                    $PrinterCount = (Get-WmiObject -Class Win32_Printer -ComputerName $Server.Name -ErrorAction SilentlyContinue).Count
                    if ($PrinterCount -gt 0) {
                        $PrintServers += [PSCustomObject]@{
                            ServerName = $Server.Name
                            OperatingSystem = $Server.OperatingSystem
                            PrinterCount = $PrinterCount
                            SpoolerStatus = $PrintSpooler.Status
                        }
                    }
                }
            } catch {}
        }
    } catch {
        Write-Log "Error identifying print servers: $($_.Exception.Message)"
    }
    
    Write-Progress -Activity "Processing Printers" -Completed
    
    # Export results
    if ($AllPrinters.Count -gt 0) {
        $AllPrinters | Export-Csv "$Global:OutputPath\AD_Published_Printers.csv" -NoTypeInformation
    }
    
    if ($PrintServers.Count -gt 0) {
        $PrintServers | Export-Csv "$Global:OutputPath\Print_Servers.csv" -NoTypeInformation
    }
    
    # Summary statistics
    $PrinterStats = [PSCustomObject]@{
        TotalPublishedPrinters = $AllPrinters.Count
        UniquePrintServers = ($AllPrinters | Select-Object -ExpandProperty ServerName -Unique).Count
        PrintServersIdentified = $PrintServers.Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $PrinterStats | Export-Csv "$Global:OutputPath\Printer_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "Printer assessment completed in $([math]::Round($PrinterStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 4: FILE SHARES ASSESSMENT

function Get-SharesAssessment {
    Write-Log "=== Starting File Shares Assessment ==="
    
    $ScriptStartTime = Get-Date
    $AllShares = @()
    
    # Get all servers
    Write-Host "Getting list of servers to scan for shares..." -ForegroundColor Yellow
    $Servers = Get-ADComputer -Filter {OperatingSystem -like "*Server*" -and Enabled -eq $true} |
        Select-Object -ExpandProperty Name
    
    $TotalServers = $Servers.Count
    Write-Log "Found $TotalServers servers to scan"
    
    $ProcessedCount = 0
    
    foreach ($Server in $Servers) {
        $ProcessedCount++
        
        $PercentComplete = ($ProcessedCount / $TotalServers) * 100
        $ETA = Get-ETA -Current $ProcessedCount -Total $TotalServers -StartTime $ScriptStartTime
        
        Write-Progress -Activity "Scanning Shares" `
            -Status "Scanning server $ProcessedCount of $TotalServers - ETA: $ETA" `
            -PercentComplete $PercentComplete `
            -CurrentOperation "Server: $Server"
        
        try {
            # Get shares from server
            $Shares = Get-WmiObject -Class Win32_Share -ComputerName $Server -ErrorAction Stop |
                Where-Object {$_.Type -eq 0}  # Disk shares only
            
            foreach ($Share in $Shares) {
                # Skip system shares
                if ($Share.Name -match '[\$]$' -and $Share.Name -notmatch '^[A-Z]\$$') { continue }
                
                $SharePath = "\\$Server\$($Share.Name)"
                
                # Determine share type
                $ShareType = "Windows Server"
                
                # Check if it's a DFS share
                $IsDFS = $false
                try {
                    $DFSPath = Get-DfsnFolder -Path $SharePath -ErrorAction SilentlyContinue
                    if ($DFSPath) { $IsDFS = $true }
                } catch {}
                
                # Get file count (with timeout)
                $FileCount = 0
                $FolderSize = 0
                
                try {
                    $Job = Start-Job -ScriptBlock {
                        param($Path)
                        $Items = Get-ChildItem -Path $Path -Recurse -ErrorAction SilentlyContinue
                        @{
                            FileCount = ($Items | Where-Object {!$_.PSIsContainer}).Count
                            FolderSize = ($Items | Where-Object {!$_.PSIsContainer} | Measure-Object -Property Length -Sum).Sum
                        }
                    } -ArgumentList $SharePath
                    
                    $Result = Wait-Job -Job $Job -Timeout 30
                    if ($Result) {
                        $JobResult = Receive-Job -Job $Job
                        $FileCount = $JobResult.FileCount
                        $FolderSize = $JobResult.FolderSize
                    }
                    Remove-Job -Job $Job -Force
                } catch {}
                
                $ShareObject = [PSCustomObject]@{
                    ServerName = $Server
                    ShareName = $Share.Name
                    SharePath = $SharePath
                    Description = $Share.Description
                    ShareType = $ShareType
                    IsDFS = $IsDFS
                    FileCount = $FileCount
                    SizeGB = [math]::Round($FolderSize / 1GB, 2)
                    MaxUserLimit = $Share.MaximumAllowed
                }
                
                $AllShares += $ShareObject
            }
        } catch {
            Write-Log "Error scanning shares on $Server : $($_.Exception.Message)"
        }
    }
    
    Write-Progress -Activity "Scanning Shares" -Completed
    
    # Export results
    if ($AllShares.Count -gt 0) {
        $AllShares | Export-Csv "$Global:OutputPath\File_Shares.csv" -NoTypeInformation
    }
    
    # DFS Namespaces
    Write-Host "Checking DFS Namespaces..." -ForegroundColor Yellow
    $DFSNamespaces = @()
    
    try {
        $DFSRoots = Get-DfsnRoot -ErrorAction SilentlyContinue
        foreach ($Root in $DFSRoots) {
            $DFSNamespaces += [PSCustomObject]@{
                NamespacePath = $Root.Path
                Type = $Root.Type
                State = $Root.State
                Description = $Root.Description
            }
        }
    } catch {
        Write-Log "Unable to query DFS namespaces: $($_.Exception.Message)"
    }
    
    if ($DFSNamespaces.Count -gt 0) {
        $DFSNamespaces | Export-Csv "$Global:OutputPath\DFS_Namespaces.csv" -NoTypeInformation
    }
    
    # Summary statistics
    $ShareStats = [PSCustomObject]@{
        TotalShares = $AllShares.Count
        TotalServersWithShares = ($AllShares | Select-Object -ExpandProperty ServerName -Unique).Count
        DFSShares = ($AllShares | Where-Object {$_.IsDFS -eq $true}).Count
        TotalFiles = ($AllShares | Measure-Object -Property FileCount -Sum).Sum
        TotalSizeGB = ($AllShares | Measure-Object -Property SizeGB -Sum).Sum
        DFSNamespaces = $DFSNamespaces.Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $ShareStats | Export-Csv "$Global:OutputPath\Share_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "Share assessment completed in $([math]::Round($ShareStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 5: GROUP POLICY ASSESSMENT

function Get-GPOAssessment {
    Write-Log "=== Starting Group Policy Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Get all GPOs
    Write-Host "Getting all Group Policy Objects..." -ForegroundColor Yellow
    $AllGPOs = Get-GPO -All
    $TotalGPOs = $AllGPOs.Count
    Write-Log "Found $TotalGPOs GPOs"
    
    $GPODetails = @()
    $ProcessedCount = 0
    
    foreach ($GPO in $AllGPOs) {
        $ProcessedCount++
        
        if ($ProcessedCount % 5 -eq 0) {
            $PercentComplete = ($ProcessedCount / $TotalGPOs) * 100
            $ETA = Get-ETA -Current $ProcessedCount -Total $TotalGPOs -StartTime $ScriptStartTime
            
            Write-Progress -Activity "Processing GPOs" `
                -Status "Processing GPO $ProcessedCount of $TotalGPOs - ETA: $ETA" `
                -PercentComplete $PercentComplete `
                -CurrentOperation "GPO: $($GPO.DisplayName)"
        }
        
        try {
            # Get GPO Report
            $GPOReport = Get-GPOReport -Guid $GPO.Id -ReportType Xml
            $GPOXml = [xml]$GPOReport
            
            # Count settings
            $ComputerSettings = 0
            $UserSettings = 0
            
            # Computer Configuration
            $CompConfig = $GPOXml.GPO.Computer
            if ($CompConfig.ExtensionData) {
                $ComputerSettings = ($CompConfig.ExtensionData | Get-Member -MemberType Property).Count
            }
            
            # User Configuration
            $UserConfig = $GPOXml.GPO.User
            if ($UserConfig.ExtensionData) {
                $UserSettings = ($UserConfig.ExtensionData | Get-Member -MemberType Property).Count
            }
            
            # Get links
            $Links = @()
            try {
                $GPOLinks = $GPOXml.GPO.LinksTo
                if ($GPOLinks) {
                    foreach ($Link in $GPOLinks) {
                        $Links += $Link.SOMPath
                    }
                }
            } catch {}
            
            # Check for scripts
            $Scripts = @()
            $ScriptTypes = @()
            
            # Check for logon scripts in GPO
            try {
                if ($GPOXml.GPO.User.ExtensionData.Extension.Script) {
                    foreach ($Script in $GPOXml.GPO.User.ExtensionData.Extension.Script) {
                        $Scripts += $Script.Command
                        $ScriptTypes += switch -Regex ($Script.Command) {
                            '\.ps1 { "PowerShell" }
                            '\.vbs { "VBScript" }
                            '\.(bat|cmd) { "Batch" }
                            default { "Other" }
                        }
                    }
                }
            } catch {}
            
            $GPOObject = [PSCustomObject]@{
                Name = $GPO.DisplayName
                Id = $GPO.Id
                Description = $GPO.Description
                CreatedTime = $GPO.CreatedTime
                ModifiedTime = $GPO.ModifiedTime
                Status = $GPO.GpoStatus
                ComputerSettingsCount = $ComputerSettings
                UserSettingsCount = $UserSettings
                TotalSettings = $ComputerSettings + $UserSettings
                LinksCount = $Links.Count
                LinkedOUs = $Links -join '; '
                IsLinked = $Links.Count -gt 0
                HasScripts = $Scripts.Count -gt 0
                ScriptCount = $Scripts.Count
                ScriptTypes = ($ScriptTypes | Select-Object -Unique) -join '; '
            }
            
            $GPODetails += $GPOObject
            
        } catch {
            Write-Log "Error processing GPO $($GPO.DisplayName): $($_.Exception.Message)"
        }
    }
    
    Write-Progress -Activity "Processing GPOs" -Completed
    
    # Export GPO details
    $GPODetails | Export-Csv "$Global:OutputPath\GPO_Details.csv" -NoTypeInformation
    
    # Get domain-level GPO links
    Write-Host "Checking domain and root-level GPO links..." -ForegroundColor Yellow
    
    $DomainLinks = @()
    try {
        $Domain = Get-ADDomain
        $DomainGPOs = Get-GPInheritance -Target $Domain.DistinguishedName
        
        foreach ($GPOLink in $DomainGPOs.GpoLinks) {
            $DomainLinks += [PSCustomObject]@{
                Target = "Domain Root"
                GPOName = $GPOLink.DisplayName
                Enabled = $GPOLink.Enabled
                Enforced = $GPOLink.Enforced
                Order = $GPOLink.Order
            }
        }
    } catch {
        Write-Log "Error getting domain GPO links: $($_.Exception.Message)"
    }
    
    if ($DomainLinks.Count -gt 0) {
        $DomainLinks | Export-Csv "$Global:OutputPath\Domain_GPO_Links.csv" -NoTypeInformation
    }
    
    # Login Scripts from User Objects
    Write-Host "Checking for login scripts assigned to user accounts..." -ForegroundColor Yellow
    
    $UserScripts = @()
    $UsersWithScripts = Get-ADUser -Filter {ScriptPath -like "*"} -Properties ScriptPath
    
    foreach ($User in $UsersWithScripts) {
        $ScriptType = switch -Regex ($User.ScriptPath) {
            '\.ps1 { "PowerShell" }
            '\.vbs { "VBScript" }
            '\.(bat|cmd) { "Batch" }
            default { "Other" }
        }
        
        $UserScripts += [PSCustomObject]@{
            UserName = $User.SamAccountName
            ScriptPath = $User.ScriptPath
            ScriptType = $ScriptType
        }
    }
    
    if ($UserScripts.Count -gt 0) {
        $UserScripts | Export-Csv "$Global:OutputPath\User_Login_Scripts.csv" -NoTypeInformation
    }
    
    # Summary statistics
    $GPOStats = [PSCustomObject]@{
        TotalGPOs = $GPODetails.Count
        LinkedGPOs = ($GPODetails | Where-Object {$_.IsLinked -eq $true}).Count
        UnlinkedGPOs = ($GPODetails | Where-Object {$_.IsLinked -eq $false}).Count
        GPOsWithScripts = ($GPODetails | Where-Object {$_.HasScripts -eq $true}).Count
        TotalScriptsInGPOs = ($GPODetails | Measure-Object -Property ScriptCount -Sum).Sum
        UsersWithLoginScripts = $UserScripts.Count
        DomainLevelGPOs = $DomainLinks.Count
        AverageSettingsPerGPO = [math]::Round(($GPODetails | Measure-Object -Property TotalSettings -Average).Average, 2)
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $GPOStats | Export-Csv "$Global:OutputPath\GPO_Summary_Stats.csv" -NoTypeInformation
    
    # Script Language Summary
    $AllScriptTypes = @()
    $AllScriptTypes += $GPODetails | Where-Object {$_.ScriptTypes} | Select-Object -ExpandProperty ScriptTypes
    $AllScriptTypes += $UserScripts | Select-Object -ExpandProperty ScriptType
    
    $ScriptLanguageSummary = $AllScriptTypes | 
        Where-Object {$_} |
        ForEach-Object {$_ -split '; '} |
        Group-Object |
        Select-Object @{N='Language';E={$_.Name}}, Count |
        Sort-Object Count -Descending
    
    if ($ScriptLanguageSummary.Count -gt 0) {
        $ScriptLanguageSummary | Export-Csv "$Global:OutputPath\Script_Language_Summary.csv" -NoTypeInformation
    }
    
    Write-Log "GPO assessment completed in $([math]::Round($GPOStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 6: CMDB DATA VALIDATION

function Get-CMDBValidation {
    Write-Log "=== Starting CMDB Data Validation ==="
    
    $ScriptStartTime = Get-Date
    
    # Check if CMDB file exists
    $CMDBPath = "$Global:OutputPath\CMDB_Import"
    if (!(Test-Path $CMDBPath)) {
        New-Item -ItemType Directory -Path $CMDBPath -Force | Out-Null
    }
    
    Write-Host "`nPlease place your CMDB export file(s) in: $CMDBPath" -ForegroundColor Yellow
    Write-Host "Supported formats: CSV, XLSX" -ForegroundColor Yellow
    Write-Host "Press Enter when ready to continue..." -ForegroundColor Yellow
    Read-Host
    
    # Get CMDB files
    $CMDBFiles = Get-ChildItem -Path $CMDBPath -Include "*.csv","*.xlsx" -Recurse
    
    if ($CMDBFiles.Count -eq 0) {
        Write-Log "No CMDB files found in $CMDBPath"
        return
    }
    
    Write-Log "Found $($CMDBFiles.Count) CMDB file(s) to process"
    
    # Process each CMDB file
    $AllCMDBData = @()
    
    foreach ($File in $CMDBFiles) {
        Write-Host "Processing CMDB file: $($File.Name)" -ForegroundColor Green
        
        try {
            if ($File.Extension -eq ".csv") {
                $CMDBData = Import-Csv -Path $File.FullName
            } elseif ($File.Extension -eq ".xlsx") {
                # Use COM object for Excel
                $Excel = New-Object -ComObject Excel.Application
                $Excel.Visible = $false
                $Workbook = $Excel.Workbooks.Open($File.FullName)
                $Worksheet = $Workbook.Worksheets.Item(1)
                
                # Convert to CSV for easier processing
                $TempCSV = "$env:TEMP\cmdb_temp.csv"
                $Worksheet.SaveAs($TempCSV, 6) # 6 = xlCSV
                $Workbook.Close()
                $Excel.Quit()
                
                $CMDBData = Import-Csv -Path $TempCSV
                Remove-Item -Path $TempCSV -Force
            }
            
            $AllCMDBData += $CMDBData
            
        } catch {
            Write-Log "Error processing CMDB file $($File.Name): $($_.Exception.Message)"
        }
    }
    
    Write-Log "Total CMDB records imported: $($AllCMDBData.Count)"
    
    # Validate CMDB data against AD
    Write-Host "Validating CMDB data against Active Directory..." -ForegroundColor Yellow
    
    $ValidationResults = @()
    $ProcessedCount = 0
    
    # Get all AD data for comparison
    $ADComputers = Import-Csv "$Global:OutputPath\All_AD_Computers.csv"
    $ADUsers = Import-Csv "$Global:OutputPath\All_AD_Users.csv"
    
    foreach ($CMDBItem in $AllCMDBData) {
        $ProcessedCount++
        
        if ($ProcessedCount % 100 -eq 0) {
            $PercentComplete = ($ProcessedCount / $AllCMDBData.Count) * 100
            Write-Progress -Activity "Validating CMDB Data" `
                -Status "Processing record $ProcessedCount of $($AllCMDBData.Count)" `
                -PercentComplete $PercentComplete
        }
        
        # Try to identify common CMDB fields
        $AssetName = $CMDBItem.PSObject.Properties | Where-Object {
            $_.Name -match "hostname|computername|name|asset.*name|device.*name"
        } | Select-Object -First 1 -ExpandProperty Value
        
        $Owner = $CMDBItem.PSObject.Properties | Where-Object {
            $_.Name -match "owner|assigned.*to|user|responsible|custodian"
        } | Select-Object -First 1 -ExpandProperty Value
        
        $AssetType = $CMDBItem.PSObject.Properties | Where-Object {
            $_.Name -match "type|category|class|asset.*type"
        } | Select-Object -First 1 -ExpandProperty Value
        
        $Status = $CMDBItem.PSObject.Properties | Where-Object {
            $_.Name -match "status|state|lifecycle"
        } | Select-Object -First 1 -ExpandProperty Value
        
        # Validate against AD
        $InAD = $false
        $ADEnabled = $false
        $ADActive = $false
        $OwnerInAD = $false
        $OwnerEnabled = $false
        $OwnerActive = $false
        
        if ($AssetName) {
            # Check if computer exists in AD
            $ADComputer = $ADComputers | Where-Object {$_.Name -eq $AssetName}
            if ($ADComputer) {
                $InAD = $true
                $ADEnabled = $ADComputer.Enabled -eq "True"
                $ADActive = $ADComputer.IsActive -eq "True"
            }
        }
        
        if ($Owner) {
            # Check if owner exists in AD
            $ADUser = $ADUsers | Where-Object {
                $_.SamAccountName -eq $Owner -or 
                $_.DisplayName -eq $Owner -or
                $_.Email -eq $Owner
            }
            if ($ADUser) {
                $OwnerInAD = $true
                $OwnerEnabled = $ADUser.Enabled -eq "True"
                $OwnerActive = $ADUser.IsActive -eq "True"
            }
        }
        
        $ValidationResult = [PSCustomObject]@{
            CMDBAssetName = $AssetName
            CMDBOwner = $Owner
            CMDBAssetType = $AssetType
            CMDBStatus = $Status
            AssetInAD = $InAD
            AssetEnabledInAD = $ADEnabled
            AssetActiveInAD = $ADActive
            OwnerInAD = $OwnerInAD
            OwnerEnabledInAD = $OwnerEnabled
            OwnerActiveInAD = $OwnerActive
            ValidationStatus = if ($InAD -and $OwnerInAD -and $OwnerActive) { "Valid" } 
                              elseif ($InAD -and !$OwnerActive) { "Owner Inactive" }
                              elseif (!$InAD) { "Asset Not in AD" }
                              else { "Invalid" }
        }
        
        $ValidationResults += $ValidationResult
    }
    
    Write-Progress -Activity "Validating CMDB Data" -Completed
    
    # Export validation results
    $ValidationResults | Export-Csv "$Global:OutputPath\CMDB_Validation_Results.csv" -NoTypeInformation
    
    # Generate summary statistics
    $CMDBStats = [PSCustomObject]@{
        TotalCMDBRecords = $ValidationResults.Count
        AssetsInAD = ($ValidationResults | Where-Object {$_.AssetInAD -eq $true}).Count
        AssetsNotInAD = ($ValidationResults | Where-Object {$_.AssetInAD -eq $false}).Count
        ValidRecords = ($ValidationResults | Where-Object {$_.ValidationStatus -eq "Valid"}).Count
        OwnersInactive = ($ValidationResults | Where-Object {$_.ValidationStatus -eq "Owner Inactive"}).Count
        OwnersNotInAD = ($ValidationResults | Where-Object {$_.OwnerInAD -eq $false}).Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $CMDBStats | Export-Csv "$Global:OutputPath\CMDB_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "CMDB validation completed in $([math]::Round($CMDBStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 7: DNS ASSESSMENT

function Get-DNSAssessment {
    Write-Log "=== Starting DNS Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Get DNS Servers
    Write-Host "Identifying DNS servers..." -ForegroundColor Yellow
    
    $DNSServers = @()
    $DomainControllers = Get-ADDomainController -Filter *
    
    foreach ($DC in $DomainControllers) {
        try {
            $DNSService = Get-Service -ComputerName $DC.Name -Name DNS -ErrorAction SilentlyContinue
            if ($DNSService) {
                $DNSServers += $DC.Name
            }
        } catch {}
    }
    
    Write-Log "Found $($DNSServers.Count) DNS servers"
    
    # Get DNS Zones
    $AllZones = @()
    $ZoneRecords = @()
    
    foreach ($DNSServer in $DNSServers) {
        Write-Host "Processing DNS server: $DNSServer" -ForegroundColor Green
        
        try {
            # Get zones from this server
            $Zones = Get-DnsServerZone -ComputerName $DNSServer -ErrorAction Stop
            
            foreach ($Zone in $Zones) {
                $ZoneObject = [PSCustomObject]@{
                    ZoneName = $Zone.ZoneName
                    ZoneType = $Zone.ZoneType
                    IsDsIntegrated = $Zone.IsDsIntegrated
                    IsReverseLookup = $Zone.IsReverseLookupZone
                    IsSigned = $Zone.IsSigned
                    DynamicUpdate = $Zone.DynamicUpdate
                    ReplicationScope = $Zone.ReplicationScope
                    DNSServer = $DNSServer
                }
                
                $AllZones += $ZoneObject
                
                # Get record count for zone
                try {
                    $Records = Get-DnsServerResourceRecord -ComputerName $DNSServer -ZoneName $Zone.ZoneName -ErrorAction Stop
                    
                    $RecordTypes = $Records | Group-Object RecordType | Select-Object Name, Count
                    
                    foreach ($RecordType in $RecordTypes) {
                        $ZoneRecords += [PSCustomObject]@{
                            ZoneName = $Zone.ZoneName
                            RecordType = $RecordType.Name
                            Count = $RecordType.Count
                            DNSServer = $DNSServer
                        }
                    }
                } catch {}
            }
        } catch {
            Write-Log "Error processing DNS server $DNSServer : $($_.Exception.Message)"
        }
    }
    
    # Get DNS Forwarders
    $Forwarders = @()
    
    foreach ($DNSServer in $DNSServers) {
        try {
            $ServerForwarders = Get-DnsServerForwarder -ComputerName $DNSServer -ErrorAction Stop
            
            foreach ($Forwarder in $ServerForwarders.IPAddress) {
                $Forwarders += [PSCustomObject]@{
                    DNSServer = $DNSServer
                    ForwarderIP = $Forwarder
                    UseRootHint = $ServerForwarders.UseRootHint
                }
            }
        } catch {}
    }
    
    # Get Conditional Forwarders
    $ConditionalForwarders = @()
    
    foreach ($DNSServer in $DNSServers) {
        try {
            $CFs = Get-DnsServerZone -ComputerName $DNSServer | Where-Object {$_.ZoneType -eq "Forwarder"}
            
            foreach ($CF in $CFs) {
                $ConditionalForwarders += [PSCustomObject]@{
                    DNSServer = $DNSServer
                    ZoneName = $CF.ZoneName
                    MasterServers = $CF.MasterServers -join '; '
                }
            }
        } catch {}
    }
    
    # Export results
    if ($AllZones.Count -gt 0) {
        $AllZones | Export-Csv "$Global:OutputPath\DNS_Zones.csv" -NoTypeInformation
    }
    
    if ($ZoneRecords.Count -gt 0) {
        $ZoneRecords | Export-Csv "$Global:OutputPath\DNS_Zone_Records.csv" -NoTypeInformation
    }
    
    if ($Forwarders.Count -gt 0) {
        $Forwarders | Export-Csv "$Global:OutputPath\DNS_Forwarders.csv" -NoTypeInformation
    }
    
    if ($ConditionalForwarders.Count -gt 0) {
        $ConditionalForwarders | Export-Csv "$Global:OutputPath\DNS_Conditional_Forwarders.csv" -NoTypeInformation
    }
    
    # DNS Statistics
    $DNSStats = [PSCustomObject]@{
        TotalDNSServers = $DNSServers.Count
        TotalZones = $AllZones.Count
        ADIntegratedZones = ($AllZones | Where-Object {$_.IsDsIntegrated -eq $true}).Count
        SignedZones = ($AllZones | Where-Object {$_.IsSigned -eq $true}).Count
        TotalForwarders = $Forwarders.Count
        ConditionalForwarders = $ConditionalForwarders.Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $DNSStats | Export-Csv "$Global:OutputPath\DNS_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "DNS assessment completed in $([math]::Round($DNSStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 8: DOMAIN CONTROLLERS AND INFRASTRUCTURE

function Get-DCInfrastructureAssessment {
    Write-Log "=== Starting Domain Controllers and Infrastructure Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Get Forest and Domain Information
    Write-Host "Getting Forest and Domain information..." -ForegroundColor Yellow
    
    $Forest = Get-ADForest
    $Domain = Get-ADDomain
    
    $ForestInfo = [PSCustomObject]@{
        ForestName = $Forest.Name
        ForestMode = $Forest.ForestMode
        RootDomain = $Forest.RootDomain
        SchemaVersion = (Get-ADObject $Forest.Schema -Properties objectVersion).objectVersion
        Domains = $Forest.Domains -join '; '
        GlobalCatalogs = $Forest.GlobalCatalogs -join '; '
        SchemaMaster = $Forest.SchemaMaster
        DomainNamingMaster = $Forest.DomainNamingMaster
    }
    
    $ForestInfo | Export-Csv "$Global:OutputPath\Forest_Information.csv" -NoTypeInformation
    
    $DomainInfo = [PSCustomObject]@{
        DomainName = $Domain.Name
        NetBIOSName = $Domain.NetBIOSName
        DomainMode = $Domain.DomainMode
        PDCEmulator = $Domain.PDCEmulator
        RIDMaster = $Domain.RIDMaster
        InfrastructureMaster = $Domain.InfrastructureMaster
        DistinguishedName = $Domain.DistinguishedName
    }
    
    $DomainInfo | Export-Csv "$Global:OutputPath\Domain_Information.csv" -NoTypeInformation
    
    # Get all Domain Controllers
    Write-Host "Analyzing Domain Controllers..." -ForegroundColor Yellow
    
    $DCs = Get-ADDomainController -Filter *
    $DCDetails = @()
    
    foreach ($DC in $DCs) {
        Write-Host "Processing DC: $($DC.Name)" -ForegroundColor Green
        
        try {
            # Get DC health and services
            $Services = @()
            $ServiceNames = @('NTDS', 'DNS', 'W32Time', 'Netlogon', 'DFSR', 'KDC')
            
            foreach ($ServiceName in $ServiceNames) {
                try {
                    $Service = Get-Service -ComputerName $DC.Name -Name $ServiceName -ErrorAction SilentlyContinue
                    if ($Service) {
                        $Services += "$ServiceName=$($Service.Status)"
                    }
                } catch {}
            }
            
            # Get OS info
            $OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $DC.Name -ErrorAction SilentlyContinue
            
            $DCObject = [PSCustomObject]@{
                Name = $DC.Name
                IPv4Address = $DC.IPv4Address
                IPv6Address = $DC.IPv6Address
                Site = $DC.Site
                IsGlobalCatalog = $DC.IsGlobalCatalog
                IsReadOnly = $DC.IsReadOnly
                OperatingSystem = $DC.OperatingSystem
                OperatingSystemVersion = $DC.OperatingSystemVersion
                Services = $Services -join '; '
                LastReboot = if ($OS) { $OS.ConvertToDateTime($OS.LastBootUpTime) } else { $null }
            }
            
            $DCDetails += $DCObject
            
        } catch {
            Write-Log "Error processing DC $($DC.Name): $($_.Exception.Message)"
        }
    }
    
    $DCDetails | Export-Csv "$Global:OutputPath\Domain_Controllers.csv" -NoTypeInformation
    
    # Get Sites and Subnets
    Write-Host "Getting Sites and Subnets..." -ForegroundColor Yellow
    
    $Sites = Get-ADReplicationSite -Filter *
    $SiteDetails = @()
    
    foreach ($Site in $Sites) {
        $Subnets = Get-ADReplicationSubnet -Filter {Site -eq $Site.DistinguishedName}
        
        $SiteObject = [PSCustomObject]@{
            SiteName = $Site.Name
            Description = $Site.Description
            Location = $Site.Location
            Subnets = ($Subnets | Select-Object -ExpandProperty Name) -join '; '
            SubnetCount = $Subnets.Count
            DomainControllers = ($DCDetails | Where-Object {$_.Site -eq $Site.Name} | Select-Object -ExpandProperty Name) -join '; '
        }
        
        $SiteDetails += $SiteObject
    }
    
    $SiteDetails | Export-Csv "$Global:OutputPath\AD_Sites.csv" -NoTypeInformation
    
    # Get Replication Status
    Write-Host "Checking Replication Status..." -ForegroundColor Yellow
    
    $ReplStatus = @()
    
    foreach ($DC in $DCs) {
        try {
            $Repl = Get-ADReplicationPartnerMetadata -Target $DC.Name -ErrorAction Stop
            
            foreach ($Partner in $Repl) {
                $ReplStatus += [PSCustomObject]@{
                    SourceDC = $DC.Name
                    PartnerDC = $Partner.Partner
                    Partition = $Partner.Partition
                    LastReplication = $Partner.LastReplicationSuccess
                    ConsecutiveFailures = $Partner.ConsecutiveReplicationFailures
                    LastError = $Partner.LastReplicationResult
                }
            }
        } catch {}
    }
    
    if ($ReplStatus.Count -gt 0) {
        $ReplStatus | Export-Csv "$Global:OutputPath\Replication_Status.csv" -NoTypeInformation
    }
    
    # Trust Relationships
    Write-Host "Getting Trust Relationships..." -ForegroundColor Yellow
    
    $Trusts = Get-ADTrust -Filter *
    $TrustDetails = @()
    
    foreach ($Trust in $Trusts) {
        $TrustDetails += [PSCustomObject]@{
            TrustName = $Trust.Name
            TrustType = $Trust.TrustType
            TrustDirection = $Trust.Direction
            TrustAttributes = $Trust.TrustAttributes
            Created = $Trust.Created
            SelectiveAuthentication = $Trust.SelectiveAuthentication
            SIDFilteringQuarantined = $Trust.SIDFilteringQuarantined
            TGTDelegation = $Trust.TGTDelegation
        }
    }
    
    if ($TrustDetails.Count -gt 0) {
        $TrustDetails | Export-Csv "$Global:OutputPath\Trust_Relationships.csv" -NoTypeInformation
    }
    
    # Infrastructure Summary
    $InfraStats = [PSCustomObject]@{
        TotalDomainControllers = $DCDetails.Count
        GlobalCatalogs = ($DCDetails | Where-Object {$_.IsGlobalCatalog -eq $true}).Count
        ReadOnlyDCs = ($DCDetails | Where-Object {$_.IsReadOnly -eq $true}).Count
        Sites = $SiteDetails.Count
        TrustRelationships = $TrustDetails.Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $InfraStats | Export-Csv "$Global:OutputPath\Infrastructure_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "DC and Infrastructure assessment completed in $([math]::Round($InfraStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 9: AD-INTEGRATED APPLICATIONS

function Get-ADApplicationsAssessment {
    Write-Log "=== Starting AD-Integrated Applications Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Service Principal Names (SPNs)
    Write-Host "Gathering Service Principal Names..." -ForegroundColor Yellow
    
    $SPNs = @()
    $ServiceAccounts = Get-ADUser -Filter {ServicePrincipalName -like "*"} -Properties ServicePrincipalName
    
    foreach ($Account in $ServiceAccounts) {
        foreach ($SPN in $Account.ServicePrincipalName) {
            $SPNs += [PSCustomObject]@{
                AccountName = $Account.SamAccountName
                AccountType = if ($Account.ObjectClass -eq "computer") { "Computer" } else { "User" }
                ServicePrincipalName = $SPN
                ServiceType = $SPN.Split('/')[0]
                Enabled = $Account.Enabled
            }
        }
    }
    
    # Also get computer SPNs
    $Computers = Get-ADComputer -Filter {ServicePrincipalName -like "*"} -Properties ServicePrincipalName
    
    foreach ($Computer in $Computers) {
        foreach ($SPN in $Computer.ServicePrincipalName) {
            $SPNs += [PSCustomObject]@{
                AccountName = $Computer.Name
                AccountType = "Computer"
                ServicePrincipalName = $SPN
                ServiceType = $SPN.Split('/')[0]
                Enabled = $Computer.Enabled
            }
        }
    }
    
    $SPNs | Export-Csv "$Global:OutputPath\Service_Principal_Names.csv" -NoTypeInformation
    
    # Common Enterprise Applications
    Write-Host "Checking for common enterprise applications..." -ForegroundColor Yellow
    
    $EnterpriseApps = @()
    
    # Exchange
    $ExchangeServers = Get-ADComputer -Filter {ServicePrincipalName -like "exchangeMDB*"} -Properties OperatingSystem
    foreach ($Server in $ExchangeServers) {
        $EnterpriseApps += [PSCustomObject]@{
            Application = "Microsoft Exchange"
            ServerName = $Server.Name
            OperatingSystem = $Server.OperatingSystem
            Type = "Email Server"
        }
    }
    
    # SQL Servers
    $SQLServers = Get-ADComputer -Filter {ServicePrincipalName -like "MSSQLSvc*"} -Properties OperatingSystem
    foreach ($Server in $SQLServers) {
        $EnterpriseApps += [PSCustomObject]@{
            Application = "Microsoft SQL Server"
            ServerName = $Server.Name
            OperatingSystem = $Server.OperatingSystem
            Type = "Database Server"
        }
    }
    
    # IIS/Web Servers
    $WebServers = Get-ADComputer -Filter {ServicePrincipalName -like "HTTP*"} -Properties OperatingSystem
    foreach ($Server in $WebServers) {
        $EnterpriseApps += [PSCustomObject]@{
            Application = "IIS/Web Server"
            ServerName = $Server.Name
            OperatingSystem = $Server.OperatingSystem
            Type = "Web Server"
        }
    }
    
    # SCCM/ConfigMgr
    $SCCMServers = Get-ADComputer -Filter {ServicePrincipalName -like "SMS*"} -Properties OperatingSystem
    foreach ($Server in $SCCMServers) {
        $EnterpriseApps += [PSCustomObject]@{
            Application = "System Center Configuration Manager"
            ServerName = $Server.Name
            OperatingSystem = $Server.OperatingSystem
            Type = "Systems Management"
        }
    }
    
    if ($EnterpriseApps.Count -gt 0) {
        $EnterpriseApps | Export-Csv "$Global:OutputPath\Enterprise_Applications.csv" -NoTypeInformation
    }
    
    # Azure AD Connect
    Write-Host "Checking for Azure AD Connect..." -ForegroundColor Yellow
    
    $AADConnectServers = @()
    $AADSyncAccounts = Get-ADUser -Filter {Name -like "MSOL_*" -or Name -like "AAD_*"} -Properties Description, WhenCreated
    
    foreach ($Account in $AADSyncAccounts) {
        $AADConnectServers += [PSCustomObject]@{
            AccountName = $Account.Name
            Description = $Account.Description
            Created = $Account.WhenCreated
            Type = "Azure AD Connect Sync Account"
        }
    }
    
    if ($AADConnectServers.Count -gt 0) {
        $AADConnectServers | Export-Csv "$Global:OutputPath\Azure_AD_Connect.csv" -NoTypeInformation
    }
    
    # LDAP-Enabled Applications (by group membership)
    Write-Host "Identifying LDAP-enabled applications..." -ForegroundColor Yellow
    
    $AppGroups = Get-ADGroup -Filter {Name -like "*app*" -or Name -like "*application*" -or Name -like "*service*"} -Properties Description, Members
    $LDAPApps = @()
    
    foreach ($Group in $AppGroups) {
        if ($Group.Members.Count -gt 0) {
            $LDAPApps += [PSCustomObject]@{
                GroupName = $Group.Name
                Description = $Group.Description
                MemberCount = $Group.Members.Count
                GroupType = $Group.GroupCategory
            }
        }
    }
    
    if ($LDAPApps.Count -gt 0) {
        $LDAPApps | Export-Csv "$Global:OutputPath\LDAP_Application_Groups.csv" -NoTypeInformation
    }
    
    # Application Summary
    $AppStats = [PSCustomObject]@{
        TotalSPNs = $SPNs.Count
        UniqueSPNTypes = ($SPNs | Select-Object -ExpandProperty ServiceType -Unique).Count
        EnterpriseApplications = $EnterpriseApps.Count
        AzureADConnectAccounts = $AADConnectServers.Count
        ApplicationGroups = $LDAPApps.Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $AppStats | Export-Csv "$Global:OutputPath\Application_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "AD Applications assessment completed in $([math]::Round($AppStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 10: SECURITY ASSESSMENT

function Get-ADSecurityAssessment {
    Write-Log "=== Starting AD Security Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Password Policy
    Write-Host "Getting Password Policy..." -ForegroundColor Yellow
    
    $DefaultDomain = Get-ADDefaultDomainPasswordPolicy
    
    $PasswordPolicy = [PSCustomObject]@{
        ComplexityEnabled = $DefaultDomain.ComplexityEnabled
        MinPasswordLength = $DefaultDomain.MinPasswordLength
        PasswordHistoryCount = $DefaultDomain.PasswordHistoryCount
        MaxPasswordAge = $DefaultDomain.MaxPasswordAge.Days
        MinPasswordAge = $DefaultDomain.MinPasswordAge.Days
        LockoutDuration = $DefaultDomain.LockoutDuration.TotalMinutes
        LockoutThreshold = $DefaultDomain.LockoutThreshold
        LockoutObservationWindow = $DefaultDomain.LockoutObservationWindow.TotalMinutes
        ReversibleEncryptionEnabled = $DefaultDomain.ReversibleEncryptionEnabled
    }
    
    $PasswordPolicy | Export-Csv "$Global:OutputPath\Password_Policy.csv" -NoTypeInformation
    
    # Fine-Grained Password Policies
    $FGPPs = Get-ADFineGrainedPasswordPolicy -Filter *
    if ($FGPPs.Count -gt 0) {
        $FGPPDetails = @()
        
        foreach ($FGPP in $FGPPs) {
            $FGPPDetails += [PSCustomObject]@{
                Name = $FGPP.Name
                Precedence = $FGPP.Precedence
                MinPasswordLength = $FGPP.MinPasswordLength
                PasswordHistoryCount = $FGPP.PasswordHistoryCount
                MaxPasswordAge = $FGPP.MaxPasswordAge.Days
                AppliesTo = ($FGPP.AppliesTo | Get-ADObject | Select-Object -ExpandProperty Name) -join '; '
            }
        }
        
        $FGPPDetails | Export-Csv "$Global:OutputPath\Fine_Grained_Password_Policies.csv" -NoTypeInformation
    }
    
    # Privileged Groups
    Write-Host "Analyzing Privileged Groups..." -ForegroundColor Yellow
    
    $PrivilegedGroups = @(
        "Domain Admins", "Enterprise Admins", "Schema Admins", 
        "Administrators", "Account Operators", "Backup Operators",
        "Server Operators", "Domain Controllers", "Read-only Domain Controllers",
        "Group Policy Creator Owners", "Cryptographic Operators"
    )
    
    $PrivilegedGroupMembers = @()
    
    foreach ($GroupName in $PrivilegedGroups) {
        try {
            $Group = Get-ADGroup -Identity $GroupName -ErrorAction Stop
            $Members = Get-ADGroupMember -Identity $Group -Recursive
            
            foreach ($Member in $Members) {
                $PrivilegedGroupMembers += [PSCustomObject]@{
                    GroupName = $GroupName
                    MemberName = $Member.Name
                    MemberType = $Member.ObjectClass
                    MemberSID = $Member.SID
                }
            }
        } catch {}
    }
    
    $PrivilegedGroupMembers | Export-Csv "$Global:OutputPath\Privileged_Group_Members.csv" -NoTypeInformation
    
    # Stale/Inactive Privileged Accounts
    Write-Host "Checking for stale privileged accounts..." -ForegroundColor Yellow
    
    $StalePrivAccounts = @()
    $PrivUsers = $PrivilegedGroupMembers | Where-Object {$_.MemberType -eq "user"} | Select-Object -ExpandProperty MemberName -Unique
    
    foreach ($UserName in $PrivUsers) {
        try {
            $User = Get-ADUser -Identity $UserName -Properties LastLogonDate, PasswordLastSet, Enabled
            
            if (!$User.Enabled -or 
                ($User.LastLogonDate -and $User.LastLogonDate -lt (Get-Date).AddDays(-90)) -or
                ($User.PasswordLastSet -and $User.PasswordLastSet -lt (Get-Date).AddDays(-180))) {
                
                $StalePrivAccounts += [PSCustomObject]@{
                    UserName = $User.Name
                    Enabled = $User.Enabled
                    LastLogon = $User.LastLogonDate
                    PasswordLastSet = $User.PasswordLastSet
                    Status = if (!$User.Enabled) { "Disabled" }
                            elseif ($User.LastLogonDate -lt (Get-Date).AddDays(-90)) { "Inactive" }
                            else { "Old Password" }
                }
            }
        } catch {}
    }
    
    if ($StalePrivAccounts.Count -gt 0) {
        $StalePrivAccounts | Export-Csv "$Global:OutputPath\Stale_Privileged_Accounts.csv" -NoTypeInformation
    }
    
    # Kerberos Settings
    Write-Host "Checking Kerberos Settings..." -ForegroundColor Yellow
    
    $KerberosPolicy = Get-ADObject -Filter {objectClass -eq "domainDNS"} -Properties *
    
    $KerberosSettings = [PSCustomObject]@{
        MaxTicketAge = $KerberosPolicy.'msDS-MaximumPasswordAge'
        MaxRenewAge = $KerberosPolicy.'msDS-LockoutDuration'
        MaxServiceAge = $KerberosPolicy.'msDS-LockoutObservationWindow'
        MaxClockSkew = "5 minutes (default)"
    }
    
    $KerberosSettings | Export-Csv "$Global:OutputPath\Kerberos_Settings.csv" -NoTypeInformation
    
    # Audit Policy (if accessible)
    Write-Host "Checking Audit Settings..." -ForegroundColor Yellow
    
    $AuditSettings = @()
    try {
        $AuditPolicies = auditpol /get /category:* /r | ConvertFrom-Csv
        
        foreach ($Policy in $AuditPolicies) {
            if ($Policy.'Subcategory' -match "Logon|Account|Directory Service|Policy Change") {
                $AuditSettings += [PSCustomObject]@{
                    Category = $Policy.Category
                    Subcategory = $Policy.Subcategory
                    Setting = $Policy.'Inclusion Setting'
                }
            }
        }
    } catch {
        Write-Log "Unable to retrieve audit settings: $($_.Exception.Message)"
    }
    
    if ($AuditSettings.Count -gt 0) {
        $AuditSettings | Export-Csv "$Global:OutputPath\Audit_Settings.csv" -NoTypeInformation
    }
    
    # Security Summary
    $SecurityStats = [PSCustomObject]@{
        PasswordMinLength = $PasswordPolicy.MinPasswordLength
        PasswordComplexity = $PasswordPolicy.ComplexityEnabled
        FineGrainedPolicies = $FGPPs.Count
        PrivilegedGroupsChecked = $PrivilegedGroups.Count
        PrivilegedUsers = $PrivUsers.Count
        StalePrivilegedAccounts = $StalePrivAccounts.Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $SecurityStats | Export-Csv "$Global:OutputPath\Security_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "Security assessment completed in $([math]::Round($SecurityStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 11: CERTIFICATE SERVICES

function Get-CertificateServicesAssessment {
    Write-Log "=== Starting Certificate Services Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Check for Certificate Authorities
    Write-Host "Checking for Certificate Authorities..." -ForegroundColor Yellow
    
    $CAs = @()
    $CAServers = Get-ADComputer -Filter {ServicePrincipalName -like "*CertSvc*"} -Properties OperatingSystem
    
    foreach ($Server in $CAServers) {
        try {
            # Get CA information
            $CAInfo = Invoke-Command -ComputerName $Server.Name -ScriptBlock {
                $CA = Get-CertificationAuthority
                return $CA
            } -ErrorAction SilentlyContinue
            
            if ($CAInfo) {
                $CAs += [PSCustomObject]@{
                    ServerName = $Server.Name
                    CAName = $CAInfo.Name
                    CAType = $CAInfo.Type
                    OperatingSystem = $Server.OperatingSystem
                }
            }
        } catch {}
    }
    
    if ($CAs.Count -gt 0) {
        $CAs | Export-Csv "$Global:OutputPath\Certificate_Authorities.csv" -NoTypeInformation
    }
    
    # Certificate Templates
    Write-Host "Getting Certificate Templates..." -ForegroundColor Yellow
    
    $Templates = @()
    try {
        $ConfigContext = ([ADSI]"LDAP://RootDSE").ConfigurationNamingContext
        $TemplatesContainer = [ADSI]"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$ConfigContext"
        
        foreach ($Template in $TemplatesContainer.Children) {
            $Templates += [PSCustomObject]@{
                TemplateName = $Template.Name
                DisplayName = $Template.DisplayName
                SchemaVersion = $Template.'msPKI-Template-Schema-Version'
                MinorVersion = $Template.'msPKI-Template-Minor-Revision'
            }
        }
    } catch {
        Write-Log "Unable to retrieve certificate templates: $($_.Exception.Message)"
    }
    
    if ($Templates.Count -gt 0) {
        $Templates | Export-Csv "$Global:OutputPath\Certificate_Templates.csv" -NoTypeInformation
    }
    
    # Certificate Summary
    $CertStats = [PSCustomObject]@{
        CertificateAuthorities = $CAs.Count
        CertificateTemplates = $Templates.Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $CertStats | Export-Csv "$Global:OutputPath\Certificate_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "Certificate Services assessment completed in $([math]::Round($CertStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region SCRIPT 12: DHCP ASSESSMENT

function Get-DHCPAssessment {
    Write-Log "=== Starting DHCP Assessment ==="
    
    $ScriptStartTime = Get-Date
    
    # Find DHCP Servers
    Write-Host "Identifying DHCP servers..." -ForegroundColor Yellow
    
    $DHCPServers = @()
    $AuthorizedServers = Get-DhcpServerInDC -ErrorAction SilentlyContinue
    
    if ($AuthorizedServers) {
        foreach ($Server in $AuthorizedServers) {
            $DHCPServers += [PSCustomObject]@{
                ServerName = $Server.DnsName
                IPAddress = $Server.IPAddress
                Authorized = $true
            }
        }
    }
    
    # Get DHCP Scopes
    $AllScopes = @()
    
    foreach ($DHCPServer in $DHCPServers) {
        Write-Host "Processing DHCP server: $($DHCPServer.ServerName)" -ForegroundColor Green
        
        try {
            $Scopes = Get-DhcpServerv4Scope -ComputerName $DHCPServer.ServerName -ErrorAction Stop
            
            foreach ($Scope in $Scopes) {
                $Statistics = Get-DhcpServerv4ScopeStatistics -ComputerName $DHCPServer.ServerName -ScopeId $Scope.ScopeId -ErrorAction SilentlyContinue
                
                $AllScopes += [PSCustomObject]@{
                    DHCPServer = $DHCPServer.ServerName
                    ScopeId = $Scope.ScopeId
                    ScopeName = $Scope.Name
                    SubnetMask = $Scope.SubnetMask
                    StartRange = $Scope.StartRange
                    EndRange = $Scope.EndRange
                    LeaseDuration = $Scope.LeaseDuration
                    State = $Scope.State
                    AddressesFree = if ($Statistics) { $Statistics.AddressesFree } else { "N/A" }
                    AddressesInUse = if ($Statistics) { $Statistics.AddressesInUse } else { "N/A" }
                    PercentageInUse = if ($Statistics) { $Statistics.PercentageInUse } else { "N/A" }
                }
            }
        } catch {
            Write-Log "Error processing DHCP server $($DHCPServer.ServerName): $($_.Exception.Message)"
        }
    }
    
    # Export results
    if ($DHCPServers.Count -gt 0) {
        $DHCPServers | Export-Csv "$Global:OutputPath\DHCP_Servers.csv" -NoTypeInformation
    }
    
    if ($AllScopes.Count -gt 0) {
        $AllScopes | Export-Csv "$Global:OutputPath\DHCP_Scopes.csv" -NoTypeInformation
    }
    
    # DHCP Summary
    $DHCPStats = [PSCustomObject]@{
        TotalDHCPServers = $DHCPServers.Count
        TotalScopes = $AllScopes.Count
        ActiveScopes = ($AllScopes | Where-Object {$_.State -eq "Active"}).Count
        ProcessingTime = ((Get-Date) - $ScriptStartTime).TotalMinutes
    }
    
    $DHCPStats | Export-Csv "$Global:OutputPath\DHCP_Summary_Stats.csv" -NoTypeInformation
    
    Write-Log "DHCP assessment completed in $([math]::Round($DHCPStats.ProcessingTime, 2)) minutes"
    
    [GC]::Collect()
}

#endregion

#region MAIN EXECUTION

function Start-ADDiscoveryAssessment {
    Write-Host "`n==================================" -ForegroundColor Cyan
    Write-Host "  AD Discovery Assessment Tool" -ForegroundColor Cyan
    Write-Host "  Version 3.0 - Complete Suite" -ForegroundColor Cyan
    Write-Host "==================================" -ForegroundColor Cyan
    Write-Host ""
    
    $TotalStartTime = Get-Date
    
    # Check for required modules
    Write-Host "Checking prerequisites..." -ForegroundColor Yellow
    $RequiredModules = @('ActiveDirectory', 'DnsServer', 'GroupPolicy')
    $MissingModules = @()
    
    foreach ($Module in $RequiredModules) {
        if (!(Get-Module -ListAvailable -Name $Module)) {
            $MissingModules += $Module
        }
    }
    
    if ($MissingModules.Count -gt 0) {
        Write-Warning "Missing required modules: $($MissingModules -join ', ')"
        Write-Host "Please install missing modules to run all assessments." -ForegroundColor Yellow
    }
    
    # Menu for selective execution
    Write-Host "`nSelect assessments to run:" -ForegroundColor Green
    Write-Host "1.  AD Users Assessment"
    Write-Host "2.  AD Computers Assessment"
    Write-Host "3.  Printers Assessment"
    Write-Host "4.  File Shares Assessment"
    Write-Host "5.  Group Policy Assessment"
    Write-Host "6.  CMDB Data Validation"
    Write-Host "7.  DNS Assessment"
    Write-Host "8.  Domain Controllers & Infrastructure"
    Write-Host "9.  AD-Integrated Applications"
    Write-Host "10. Security Assessment"
    Write-Host "11. Certificate Services"
    Write-Host "12. DHCP Assessment"
    Write-Host "13. Run All Assessments"
    Write-Host ""
    
    $Selection = Read-Host "Enter your selection (1-13)"
    
    switch ($Selection) {
        "1" { Get-ADUsersAssessment }
        "2" { Get-ADComputersAssessment }
        "3" { Get-PrintersAssessment }
        "4" { Get-SharesAssessment }
        "5" { Get-GPOAssessment }
        "6" { Get-CMDBValidation }
        "7" { Get-DNSAssessment }
        "8" { Get-DCInfrastructureAssessment }
        "9" { Get-ADApplicationsAssessment }
        "10" { Get-ADSecurityAssessment }
        "11" { Get-CertificateServicesAssessment }
        "12" { Get-DHCPAssessment }
        "13" {
            Get-ADUsersAssessment
            Get-ADComputersAssessment
            Get-PrintersAssessment
            Get-SharesAssessment
            Get-GPOAssessment
            Get-CMDBValidation
            Get-DNSAssessment
            Get-DCInfrastructureAssessment
            Get-ADApplicationsAssessment
            Get-ADSecurityAssessment
            Get-CertificateServicesAssessment
            Get-DHCPAssessment
        }
        default {
            Write-Host "Invalid selection. Exiting." -ForegroundColor Red
            return
        }
    }
    
    $TotalTime = ((Get-Date) - $TotalStartTime).TotalMinutes
    
    Write-Host "`n==================================" -ForegroundColor Green
    Write-Host "  Assessment Complete!" -ForegroundColor Green
    Write-Host "  Total Time: $([math]::Round($TotalTime, 2)) minutes" -ForegroundColor Green
    Write-Host "  Results saved to: $Global:OutputPath" -ForegroundColor Green
    Write-Host "==================================" -ForegroundColor Green
    
    # Create comprehensive summary report
    $FinalSummary = @"
Active Directory Discovery Assessment Summary
===========================================
Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
Total Processing Time: $([math]::Round($TotalTime, 2)) minutes

Output Directory: $Global:OutputPath

Assessment Areas Covered:
- User Accounts (Standard, Admin, Service)
- Computer Accounts and OS Inventory
- Group Policy Objects and Scripts
- File Shares and DFS Configuration
- Print Services
- DNS Infrastructure
- Domain Controllers and Replication
- Certificate Services
- DHCP Services
- Security Configuration
- AD-Integrated Applications
- CMDB Validation

Files Generated:
$(Get-ChildItem -Path $Global:OutputPath -Filter "*.csv" | Select-Object -ExpandProperty Name | ForEach-Object {"- $_"})

Key Recommendations:
1. Review inactive and non-compliant systems
2. Validate CMDB accuracy against AD data
3. Identify stale privileged accounts
4. Document AD-integrated applications
5. Plan for legacy OS migrations
6. Review security policies and audit settings

Next Steps:
1. Import CSV data into PowerPoint/Excel for presentation
2. Create migration scope based on findings
3. Develop remediation plan for identified issues
4. Schedule follow-up assessments
"@
    
    $FinalSummary | Out-File "$Global:OutputPath\Assessment_Summary.txt"
    Write-Host "`nComprehensive summary report saved to: $Global:OutputPath\Assessment_Summary.txt" -ForegroundColor Yellow
}

# Execute the main function
Start-ADDiscoveryAssessment

#endregion
